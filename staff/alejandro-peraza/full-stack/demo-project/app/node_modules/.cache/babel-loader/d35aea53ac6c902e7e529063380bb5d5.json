{"ast":null,"code":"const EMAIL_REGEX = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nconst BLANK_REGEX = /^\\s+$/;\nconst SPACE_REGEX = /\\s/;\nconst SPACES_AROUND_REGEX = /^\\s[aA-zZ]\\s?[aA-zZ]|[aA-zZ]\\s?[aA-zZ]\\s$/;\n\nfunction validateEmail(email) {\n  if (typeof email !== 'string') throw new TypeError('email is not a string');\n  if (email === '') throw new Error('empty email');\n  if (BLANK_REGEX.test(email)) throw new Error('blank email');\n  if (!EMAIL_REGEX.test(email)) throw new Error('invalid email');\n}\n\nfunction validatePassword(password) {\n  let explain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'password';\n  if (typeof password !== 'string') throw new TypeError(`${explain} is not a string`);\n  if (BLANK_REGEX.test(password)) throw new Error(`blank ${explain}`);\n  if (SPACE_REGEX.test(password)) throw new Error(`${explain} has empty spaces`);\n  if (password === '') throw new Error(`empty ${explain}`);\n  if (password.length < 8) throw new Error(`${explain} is shorter than 8 characters`);\n}\n\nfunction validateToken(token) {\n  if (typeof token !== 'string') throw new TypeError('token is not a string');\n  const parts = token.split('.');\n  if (parts.length !== 3) throw new Error('token it not valid');\n  parts.forEach(part => {\n    if (part === '') throw new Error('token part is empty');\n    if (BLANK_REGEX.test(part)) throw new Error('token part is blank');\n  });\n  const [header, payload] = parts;\n\n  try {\n    atob(header);\n  } catch (error) {\n    throw new Error('token invalid');\n  }\n\n  let json;\n\n  try {\n    json = atob(payload);\n  } catch (error) {\n    throw new Error('token invalid');\n  }\n\n  const {\n    exp\n  } = JSON.parse(json);\n  const expStamp = exp * 1000;\n  const expired = Date.now() > expStamp;\n  if (expired) throw new Error('token expired');\n}\n\nfunction validateString(string) {\n  let explain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'string';\n  if (typeof string !== 'string') throw new TypeError(`${explain} is not a string`);\n  if (string === '') throw new Error(`empty ${explain}`);\n  if (BLANK_REGEX.test(string)) throw new Error(`blank ${explain}`);\n  if (SPACES_AROUND_REGEX.test(string)) throw new Error(`${explain} has spaces around`);\n}\n\nmodule.exports = {\n  validateEmail,\n  validatePassword,\n  validateToken,\n  validateString\n};","map":{"version":3,"sources":["C:/Users/Alex/workspace/neoland-bootcamp-202201/staff/alejandro-peraza/full-stack/demo-project/commons/src/validators.js"],"names":["EMAIL_REGEX","BLANK_REGEX","SPACE_REGEX","SPACES_AROUND_REGEX","validateEmail","email","TypeError","Error","test","validatePassword","password","explain","length","validateToken","token","parts","split","forEach","part","header","payload","atob","error","json","exp","JSON","parse","expStamp","expired","Date","now","validateString","string","module","exports"],"mappings":"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","sourcesContent":["const EMAIL_REGEX = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\r\nconst BLANK_REGEX = /^\\s+$/\r\nconst SPACE_REGEX = /\\s/\r\nconst SPACES_AROUND_REGEX = /^\\s[aA-zZ]\\s?[aA-zZ]|[aA-zZ]\\s?[aA-zZ]\\s$/\r\n\r\nfunction validateEmail(email) {\r\n    if (typeof email !== 'string') throw new TypeError('email is not a string')\r\n    if (email === '') throw new Error('empty email')\r\n    if (BLANK_REGEX.test(email)) throw new Error('blank email')\r\n    if (!EMAIL_REGEX.test(email)) throw new Error('invalid email')\r\n}\r\n\r\nfunction validatePassword(password, explain = 'password') {\r\n    if (typeof password !== 'string') throw new TypeError(`${explain} is not a string`)\r\n    if (BLANK_REGEX.test(password)) throw new Error(`blank ${explain}`)\r\n    if (SPACE_REGEX.test(password)) throw new Error(`${explain} has empty spaces`)\r\n    if (password === '') throw new Error(`empty ${explain}`)\r\n    if (password.length < 8) throw new Error(`${explain} is shorter than 8 characters`)\r\n}\r\n\r\nfunction validateToken(token) {\r\n    if (typeof token !== 'string') throw new TypeError('token is not a string')\r\n\r\n    const parts = token.split('.')\r\n\r\n    if (parts.length !== 3) throw new Error('token it not valid')\r\n\r\n    parts.forEach(part => {\r\n        if (part === '') throw new Error('token part is empty')\r\n        if (BLANK_REGEX.test(part)) throw new Error('token part is blank')\r\n    })\r\n\r\n    const [header, payload] = parts\r\n\r\n    try {\r\n        atob(header)\r\n    } catch (error) {\r\n        throw new Error('token invalid')\r\n    }\r\n\r\n    let json\r\n    \r\n    try {\r\n        json = atob(payload)\r\n    } catch(error) {\r\n        throw new Error('token invalid')\r\n    }\r\n\r\n    const { exp } = JSON.parse(json)\r\n\r\n    const expStamp = exp * 1000\r\n\r\n    const expired = Date.now() > expStamp\r\n\r\n    if (expired) throw new Error('token expired')\r\n}\r\n\r\nfunction validateString(string, explain = 'string') {\r\n    if (typeof string !== 'string') throw new TypeError(`${explain} is not a string`)\r\n    if (string === '') throw new Error(`empty ${explain}`)\r\n    if (BLANK_REGEX.test(string)) throw new Error(`blank ${explain}`)\r\n    if (SPACES_AROUND_REGEX.test(string)) throw new Error(`${explain} has spaces around`)\r\n}\r\n\r\nmodule.exports = {\r\n    validateEmail,\r\n    validatePassword,\r\n    validateToken,\r\n    validateString\r\n}\r\n"]},"metadata":{},"sourceType":"script"}